
# 2024.01.04

프로그래머스 > 코딩테스트 연습 > 연습문제 > [가장 가까운 같은 글자](https://school.programmers.co.kr/learn/courses/30/lessons/142086)

---
### 📌 Part 1. 문제 해결 절차
_※ 중첩 반복문을 사용해서 해결_<br>
```
1. 매개변수로 받아오는 문자열을 문자 배열로 변환한다.
2. answer의 첫 번째 요소 값을 -1로 둔다. (첫 번째 요소의 앞 -1이니까)
3. 문자열의 i = 1 번째 요소부터 하나씩 증가하는 반복문을 돌린다.
    3-1. 문자열의 j = i-1 번째 요소부터 하나씩 감소하는 반복문을 돌린다.
    3-2. c[i]와 c[j]가 같다면 answer[i]에 인덱스 i - j 값을 넣고 j 반복문을 나간다.
    3-3. 같지 않다면 answer[i]에 -1를 넣는다.
```
처음에는 j 반복문을 i-1번째 부터 증가하는 반복문을 돌렸었다.<br>
그렇게 하니까 가장 멀리 있는 위치의 같은 문자의 인덱스 차이 값을 넣고 반복문을 빠져나가는 것이었다.<br>
그래서 증가가 아닌 감소를 하면서 뒤에서부터 내려가는 게 맞는 흐름이라 느꼈다.<br>
문제를 풀면서 log 를 하나씩 찍었고, 출력된 값을 보면서 돌아가는 흐름을 이해하려고 했다.<br>
그 결과 도움이나 힌트없이 해결할 수 있었던 것 같다.<br>
<br>

---
### 📌 Part 2. 다른 사람의 풀이
_※ 다른 사람의 풀이를 보고, 해석하는 시간을 가진다._<br>
```
class Solution {
    public int[] solution(String str) {
        int[] result = new int[str.length()];

        for(int i=0; i<str.length(); i++){
            // 현재 인덱스까지의 부분 문자열을 구함
            String subStr = str.substring(0, i);

            // 만약 현재 문자가 부분 문자열에 존재하지 않으면
            if(subStr.indexOf(str.charAt(i)) == -1) {
                // 현재 위치에 -1을 저장
                result[i] = -1;
            } else {
                // 현재 문자가 부분 문자열에 존재하면
                // 현재 위치에서 마지막으로 등장한 위치까지의 거리를 계산하여 저장
                result[i] = i - subStr.lastIndexOf(str.charAt(i));
            }
        }
        return result;
    }
}
```
나는 중첩 반복문을 사용했는데, 반복문이 중첩될 수록 효율성? 테스트가 떨어지는 것으로 알고 있다.<br>
그렇기에 이렇게 반복문 하나로 돌리는 방법을 익혀야 할 것 같다.<br>
그리고 위의 코드를 보면서 indexOf()나 lastIndexOf()를 알고 이용했기에 중첩 반복문이 필요 없어지는 것 같다.<br>
좋은 메소드들이 많구나 싶다. 나도 여러 메소드를 이용해서 문제를 풀고 싶다.<br>
<br>

---
### 🙄 Part 3. 생각
오늘은 풀 수 있을 것 같은데 안풀려서 조금 고집을 부렸다.<br>
그래서 한 10분 정도 초과한 시간에 commit을 했던 것 같다.<br>
그 결과 혼자만의 힘으로 문제를 풀 수 있었는데, <br>
문제 해결 절차를 처음으로 중점으로 생각하고 푼 문제 같아서 기분이 좋다.<br>
단순히 문제를 풀었다는 이유보다 절차의 흐름을 인지하려고 노력했던 점이 개인적으로 좋았다.<br>
<br>
문제를 해결하려면 펜과 종이만으로도 문제를 풀 수 있어야 하는 것 같다.<br>
펜과 종이로도 못 푸는데 다짜고짜 코드를 만들려고 하면 의미가 없는 것 같다.<br>
더더 연습하자 !!
<br>