
# 2024.02.01

프로그래머스 > 코딩테스트 연습 > 완전탐색 > [카펫](https://school.programmers.co.kr/learn/courses/30/lessons/42842)

---
### 🍊 완전 탐색이란?
알고리즘에서 사용되는 기법 중 하나로 '모든 가능한 경우의 수를 탐색'하여 '최적의 결과를 찾는 방법'을 의미한다.<br>
모든 가능성을 고려하기 때문에 항상 최적의 해를 찾을 수 있지만 경우의 수가 매우 많은 경우 시간과 메모리의 부담이 커질 수 있습니다.<br>
그렇기에 문제의 특성에 따라 다른 탐색 기법을 사용하는 것이 좋습니다.<br>
<br>
#### <완전 탐색의 종류>
- 브루트 포스 : '모든 경우의 수를 다 탐색'하면서 원하는 결과를 얻는 알고리즘을 의미한다.
- 비트마스크 : '모든 경우의 수'를 이진수로 표현하고 '비트 연산'을 통해 원하는 결과를 빠르게 얻는 알고리즘을 의미한다.
- 백트래킹 : 결과를 얻기 위해 진행하는 도중에 '막히게 되면' 그 지점으로 다시 돌아가서 '다른 경로를 탐색'하는 방식을 의미한다. 결국 모든 가능한 경우의 수를 탐색하여 해결책을 찾는다.
- 순열 : '순열'을 이용하여 모든 경우의 수를 탐색하는 방법이다. 순열은 서로 다른 n개 중에서 r개를 선택하여 나열하는 방법을 의미한다.
- 재귀함수 : 자기 자신을 호출하여 모든 가능한 경우의 수를 체크하면서 최적의 해답을 얻는 방식을 의미한다.
- DFS(깊이 우선 탐색) : 루트 노드에서 시작하여 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법을 의미한다.
- BFS(너비 우선 탐색) : 루트 노드에서 시작하여 인접한 노드를 먼저 탐색하는 방법을 의미한다.
<br>

### 📌 Part 1. 문제 해결 절차
_※ 격자 안에 존재하는 yellow의 값에 대한 검증을 못해서 (실패)_<br>
```
1. brown과 yellow을 더한 all 값을 가지고 만들 수 있는 위치 찾기
    1-1. all % i가 0이고(=> 나누어 떨어짐), all / i 해서 나온 값은 height(높이)가 된다.
2. 여기서 높이가 j보다 작다면 탈락
3. 남은 수 중에서 가로 수가 작은 수를 리턴
```
위의 절차와 같이 풀었더니, 테스트 케이스가 모두 통과했으나 실제 제출에서 3개의 문제가 실패로 떴다.<br>
그래서 반례를 찾아보니 (18, 6)이 들어오면 (8, 3)이 반환되어야 하는데 나는 (6, 4)가 반환되고 있었다.<br>
즉, 격자 안에 존재하는 yellow의 크기가 실제로 존재하는 yellow 크기와 같은지 확인하는 작업이 누락되어서 그렇다.<br>
<br>
그래서 i * 2 해서 나온 값을 (height -1)와 더하여 준 값을 구하고,<br>
구한 값과 brown 값을 빼서 yellow와 값이 같다면 해당 위치에 존재하는 값을 반환해라.<br>
라고 생각을 했으나, 하나가 구현이 되니 다른 하나가 구현이 안됐다.<br>
그래서 정답을 찾아보았다.<br>
<br>

---
### 📌 Part 2. 다른 사람의 풀이
_※ 다른 사람의 풀이를 보고, 해석하는 시간을 가진다. (정답 코드)_<br>
```
class Solution {
    public int[] solution(int brown, int yellow) {
        int[] answer = new int[2];

        int all = brown + yellow; // 총 격자의 수
        int height = 0; // 세로의 길이

        for(int i = 1; i < brown; i++){
            height = all / i;

            // 카펫 안에 패워지는 노란색 격자 수가 yellow와 같아야 한다.
            if((i-2) * (height-2) == yellow){
                answer[0] = i;
                answer[1] = height;
            }
        }
        return answer;
    }
}
```
(x-2)(y-2) == yellow 부분을 이해하지 못해서 문제가 쉽지 않다고 느낀 것 같다.<br>
```
B B B B B 
B Y Y Y B
B Y Y Y B
B B B B B
```
여기서 B는 갈색, Y는 노란색 일 때, <br>
가로 길이를 x,세로 길이를 y라고 하면<br>
전체 카펫의 격자 수는 `x * y`가 된다.<br>
<br>
노란색 격자가 테두리에 위치라는 경우,<br>
각 행과 열의 두번 째 격자부터 카펫의 테두리까지가 노란색 격자로 채워진다.<br>
그러므로 `(x-2)(y-2)`가 주어진 노란색 격자의 수가 된다.<br>
<br>
그냥 문제를 풀려고 한다면, 나는 이런 수학적인 생각은 전혀 하지 못하는 것 같다.<br>
이렇게 푸는 거구나 하고 넘어가야 겠다.
<br>

---
### 🙄 Part 3. 생각
오늘 문제 풀면서 다른 소식 때문에 좀 왔다갔다 하느라<br>
이 문제 하나 붙잡고 있는데에 시간이 많이 걸렸다.<br>
다시 또 쉬운 문제로 가야하나 고민이다.<br>
해당 문제는 알고 풀었다기 보다,<br>
어떻게 구현할지 몰라서 쩔쩔 매다가<br>
내가 이해할 수 있는 답을 보고 풀었다고 느낀다.<br>
자바의 기본적인 문법을 다시 제대로 익혀야 할 것 같다.
<br>