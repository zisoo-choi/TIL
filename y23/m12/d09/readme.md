# 2023.12.09
프로그래머스 > 코딩테스트 연습 > 해시 > [베스트앨범](https://school.programmers.co.kr/learn/courses/30/lessons/42579)<br>
프로그래머스 > 코딩테스트 연습 > 탐욕법(Greedy) > [체육복](https://school.programmers.co.kr/learn/courses/30/lessons/42862?language=java)

### 그리디 알고리즘
사전 상 Greedy는 탐욕스러운, 욕심많은 이라는 의미를 가지고 있는 영어단어이다.<br>
즉, "현재 상황에서 지금 당장 좋은 것만 고르는 방법"으로 문제를 해결하는 방법이다.<br>

- 코딩 테스트에서 만날 경우, 사전에 외우고 있지 않아도 풀 수 있는 가능성이 높은 문제 유형이다.<br>
- 창의력(문제를 풀기 위한 최소의 아이디어)을 요구하는 문제 유형
<br><br>

<b>※ 예제 - 거스름 돈</b>
```
마트에서 계산을 하는 점원이 되었다.
손님에게 거슬러줘야 할 돈이 N원일 때, 거슬로줘야 할 동전의 개수를 구하라.
이 때 거스름 돈으로 사용할 동전은 500원, 100원, 50원, 10원으로 무한히 존재하고,
N은 10의 배수로 가정한다.
```
- 입력 예시 : 1,460
- 출력 예시 : 8

<br>
<b>※ 요점</b><br>
최소 개수를 구하기 위해서는 "가장 큰 화폐 단위부터" 돈을 거슬러 준다.<br>

### 생각
처음에 문제를 혼자 풀어서 테스트 코드는 통과를 했는데,<br>
프로그래머스에 런타임 에러 및 실패가 떠서 당황하다가 챗 지피티에게 물어보았다.<br>
그런데 챗 지피티가 깔끔한 코드로 변경하는 법만 알려주고, 지피티가 준 코드도 통과가 안되었다.<br>
이후 구글에 검색했는데 다른 사람들의 풀이는 어렵고 이해가 안되서
챗 지피티가 알려준 깔끔한 코드에서 고민을 해봤다.<br>
나는 17, 18, 19, 20, 25 테스트를 통과를 못하고 있었고,
더이상 방법이 없고 막막하여 테스트 코드를 고안해서 추가해보았다.<br>
<br>
```
n = 10
int[] lost = {2, 4, 6, 8}
int[] reserve = {2, 4, 5, 7}
```
- 위와 같은 테스트 코드를 추가한 이유<br>
도난당하지 않은 학생이 여벌의 체육복을 가져왔을 경우 + 바로 앞 뒤에 사이를 두고 그런 친구가 있다면? 을 생각해봤다.
<br> 그래서 { 1 1 1 1 2 0 2 0 1 1 } 과 같은 값에서 어떻게 해볼지 생각하려고 했다.

위와 같이 추가했더니, 통과가 안되는 것이었다.<br>
그래서 해당 테스트 케이스에 맞게 약간 수정을 했더니 이번에는 1번 테스트 케이스가 실패했다.<br>
여기서 테스트 케이스를 적절하게 골랐다고 생각하면서 1과 새로운 테스트 코드 모두를 만족시킬 로직을 생각했다.<br>
실제 흐름에 대해서 그림으로 그리면서 해봤고, 그 결과<br>
```
        // 도난 당한 학생에게 빌려주기
        for (int i = 1; i <= n; i++) {
            // 도난 당한 학생 중에
            if (arr[i] == 0) {
                // 앞 친구가 도난 안 당하고, 여벌 옷까지 2개인 경우
                if(arr[i-1] == 2){
                    arr[i-1]--;
                    arr[i]++;
                }
                // 뒤 친구가 이하 동문 2개인 경우
                if(arr[i] != 1 && arr[i+1] == 2) {
                    arr[i+1]--;
                    arr[i]++;
                }
            }
        }

        for(int i = 1; i <= n; i++){
            if(arr[i] >= 1){
                answer++;
            }
        }
```
<b>case 3이 실패한 이유 (=> 내가 새로 넣은 테스트)</b><br>
- 해당 코드에서 "뒤 친구가 이하 동문 2개인 경우" 부분에 arr[i] != 1를 추가해주었다.<br>
- arr[i] != 1를 추가하지 않으면 전의 if 문에서 0 -> 1 로 바뀐 부분을 인식하지 못하고 중복 연산을 하게 된다.<br>
- { 1 1 1 1 2 <b style=color:red>0</b> 2 0 1 1 } => { 1 1 1 1 1 <b style=color:red>1</b> 2 0 1 1 } 1차적으로 이와 같이 변경되었으나,
- 다음 if문을 또 들어가게 되어 { 1 1 1 1 1 <b style=color:red>2</b> 1 0 1 1 }이 되어 버린다.<br>
<br>

<b>case 1이 실패한 이유</b><br>
- 아래 count를 하는 코드에서 arr[i] >= 1 해당 부분 추가로 인해 { 1 1 1 1 <b style=color:red>2</b> }과 같은 상황을 타파하는 것 까지 잘 끝냈다.<br>

<br>
문제가 안 풀린다고 손놓고 기다린 게 아니라, 해결하고자 테스트 코드를 고안하여 넣고 해결한 게 뿌듯하다.<br>